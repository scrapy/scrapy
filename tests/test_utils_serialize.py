import sys
import json
import unittest
import datetime
from decimal import Decimal

from twisted.internet import defer

from scrapy.utils.serialize import ScrapyJSONEncoder
# from adhoc_tool.annotated_sources.annotated_serialize import ScrapyJSONEncoder
from scrapy.http import Request, Response
from scrapy.item import BaseItem

from adhoc_tool.adhoc_cov_config import BRANCHES, BRANCH_COUNT, branch_coverage_summary
from unittest.mock import MagicMock


class JsonEncoderTestCase(unittest.TestCase):

    def setUp(self):
        self.encoder = ScrapyJSONEncoder()

    @classmethod
    def tearDownClass(cls):
        # Print branch coverage metrics generated by ad-hoc coverage tool
        if 'adhoc_tool.adhoc_cov_config' in sys.modules:
            branch_coverage_summary(10)

    def test_encode_decode(self):
        dt = datetime.datetime(2010, 1, 2, 10, 11, 12)
        dts = "2010-01-02 10:11:12"
        d = datetime.date(2010, 1, 2)
        ds = "2010-01-02"
        t = datetime.time(10, 11, 12)
        ts = "10:11:12"
        dec = Decimal("1000.12")
        decs = "1000.12"
        s = {'foo'}
        ss = ['foo']
        dt_set = {dt}
        dt_sets = [dts]

        for input, output in [('foo', 'foo'), (d, ds), (t, ts), (dt, dts),
                              (dec, decs), (['foo', d], ['foo', ds]), (s, ss),
                              (dt_set, dt_sets)]:
            self.assertEqual(self.encoder.encode(input), json.dumps(output))

    def test_encode_deferred(self):
        self.assertIn('Deferred', self.encoder.encode(defer.Deferred()))

    def test_encode_request(self):
        r = Request("http://www.example.com/lala")
        rs = self.encoder.encode(r)
        self.assertIn(r.method, rs)
        self.assertIn(r.url, rs)

    def test_encode_response(self):
        r = Response("http://www.example.com/lala")
        rs = self.encoder.encode(r)
        self.assertIn(r.url, rs)
        self.assertIn(str(r.status), rs)

    def test_encode_base_item(self):
        """
        Test demonstrating invalid handling of BaseItem in utils/serialize.py
        If object to encode as JSON is a of type BaseItem, an attempt to create a
        dict out of a BaseItem is made, but BaseItem cannot be converted to dict,
        and thus a TypeError exception is raised.
        """
        d = {1: "1"}
        b = BaseItem(d)
        self.assertRaises(TypeError, self.encoder.encode, b)
